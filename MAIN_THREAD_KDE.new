#!/bin/bash

#modified for 4 inch SPI device/Pi Zero
#now modified for 5 inch HDMI device/Pi 3
#now modified for odroid c2
#now modified for odroid c0
#now modified for lattepanda (original)
#now modified again for odroid c0
#now modified for pi 4
#now modified again for lattepanda (original)
#now modified for x86 pc stick
#now modified for khadas vim3

#start as awake always
echo 0 > /home/pi/SLEEP_STATUS

#for suspend checking
STORED_WAKEUP_TIMESTAMP=0

#shut off ethernet one time
#trying to disable ethernet through configs is problematic
#when networkmanager releases the interface suspend breaks
sudo ifconfig eth0 down

#for new modem enumeration after various events
#OLD_MODEM_NUMBER=$(mmcli -L | cut -c42-43)
OLD_MODEM_NUMBER=$(mmcli -L | cut -d "/" -f6 | cut -d " " -f1)
MODEM_NUMBER=$OLD_MODEM_NUMBER

BOOT_STATUS=$( awk '{ print }' /home/pi/FIRST_BOOT )
if [ "$BOOT_STATUS" -eq "1" ]
then
#remove stale bluetooth references
sudo sh -c 'rm -r /var/lib/bluetooth/*'
#zenity --notification --window-icon="info" --text "Standby - waiting for cellular device to settle"&
kdialog --passivepopup "Standby - waiting for cellular device to settle" 1
sleep 5
#zenity --notification --window-icon="info" --text "Standby - waiting for cellular device to settle"&
kdialog --passivepopup "Standby - waiting for cellular device to settle" 1
sleep 5
#temporarily setup touchscreen
#xinput set-prop 'ADS7846 Touchscreen' 'Evdev Third Button Emulation' 0
#xinput set-prop 'ADS7846 Touchscreen' 'Evdev Axis Inversion' 0 1
#xinput set-prop 'ADS7846 Touchscreen' 'Evdev Axes Swap' 1
#for model 15 with waveshare 5" capacitive touchscreen
#no calibration needed and old calibration should not interfere
#third button emulation - hold to right click - does not work
#xinput set-prop 'waveshare multi-point Touchscreen' 'Evdev Axis Inversion' 0 1
#xinput set-prop 'waveshare multi-point Touchscreen' 'Evdev Axes Swap' 1
#for model 16 - apparently x86 does not use evdev by default
#looks like model 17 can use either method but previous is best
#this is because it can be setup without scripting
#~/TOUCH
#for x86 pc stick
#ORIENTATION_STATUS=$( awk '{ print }' /home/pi/ORIENTATION_MODE )
#if [ "$ORIENTATION_STATUS" -eq "0" ]
#then
#~/PORTRAIT_MODE
#fi
#if [ "$ORIENTATION_STATUS" -eq "1" ]
#then
#~/LANDSCAPE_MODE
#fi
#initial cellular configuration
sudo rm /etc/wvdial.conf
PROVIDER=$( kdialog --radiolist "Choose your cellular provider:" 1 "ATT" on 2 "ATT Prepaid" off 3 "Tmobile" off )
#PROVIDER=$(zenity --list --title="Choose your cellular provider" --column="Providers" ATT "ATT Prepaid" Tmobile)
if [ "$PROVIDER" -eq 1 ]
#if [ "$PROVIDER" = "ATT" ]
then
#att
echo ATT > /home/pi/PROVIDER
ADAPTER_CHECK_1=$(sudo lsusb -v | grep Product | grep 340 | wc -l)
if [ $ADAPTER_CHECK_1 -gt 0 ]
then
#continuous programming - used each boot
sudo cp /home/pi/mbim-network.conf.ATT /etc/mbim-network.conf
fi
#for model 17 - previous was more specific and less privileged
#for older kernels
#ADAPTER_CHECK_2=$(lsusb -v | grep Product | grep E398 | wc -l)
#for newer kernels - for model 16
ADAPTER_CHECK_2=$(sudo lsusb -v | grep Product | grep 'HUAWEI Mobile' | wc -l)
if [ $ADAPTER_CHECK_2 -gt 0 ]
then
#continuous programming - used each boot
sudo cp /home/pi/wvdial.conf.ATT /etc/wvdial.conf
fi
fi
if [ "$PROVIDER" -eq 2 ]
#if [ "$PROVIDER" = "ATT Prepaid" ]
then
#att prepaid
echo ATT_PREPAID > /home/pi/PROVIDER
ADAPTER_CHECK_1=$(sudo lsusb -v | grep Product | grep 340 | wc -l)
if [ $ADAPTER_CHECK_1 -gt 0 ]
then
#continuous programming - used each boot
sudo cp /home/pi/mbim-network.conf.ATTPREPAID /etc/mbim-network.conf
fi
#for model 17 - previous was more specific and less privileged
#for older kernels
#ADAPTER_CHECK_2=$(lsusb -v | grep Product | grep E398 | wc -l)
#for newer kernels - for model 16
ADAPTER_CHECK_2=$(sudo lsusb -v | grep Product | grep 'HUAWEI Mobile' | wc -l)
if [ $ADAPTER_CHECK_2 -gt 0 ]
then
#continuous programming - used each boot
sudo cp /home/pi/wvdial.conf.ATTPREPAID /etc/wvdial.conf
fi
fi
if [ "$PROVIDER" -eq 3 ]
#if [ "$PROVIDER" = "Tmobile" ]
then
#tmobile
echo TMOBILE > /home/pi/PROVIDER
ADAPTER_CHECK_1=$(sudo lsusb -v | grep Product | grep 340 | wc -l)
if [ $ADAPTER_CHECK_1 -gt 0 ]
then
#continuous programming - used each boot
sudo cp /home/pi/mbim-network.conf.TMOBILE /etc/mbim-network.conf
fi
#for model 17 - previous was more specific and less privileged
#for older kernels
#ADAPTER_CHECK_2=$(lsusb -v | grep Product | grep E398 | wc -l)
#for newer kernels - for model 16
ADAPTER_CHECK_2=$(sudo lsusb -v | grep Product | grep 'HUAWEI Mobile' | wc -l)
if [ $ADAPTER_CHECK_2 -gt 0 ]
then
#continuous programming - used each boot
sudo cp /home/pi/wvdial.conf.TMOBILE /etc/wvdial.conf
fi
fi
feh -x -. /home/pi/GESTURES.jpg&
kdialog --msgbox "Press OK when finished reviewing gestures tutorial"
#zenity --info --text="Press OK when finished reviewing gestures tutorials"
echo "0" > /home/pi/FIRST_BOOT
#for model 16 - there seems to be no reason to reboot anymore
#kdialog --passivepopup "Your system is configured - rebooting" 1
#zenity --info --text="Your system is configured - press OK to reboot"
if kdialog --title "Continue Check" --warningcontinuecancel "Configuration complete.  Press Continue to continue startup or Cancel to quit for now to make other changes."
then
killall feh
echo "Continue"
else
echo "cancel"
killall feh
exit
fi
fi

echo "1" > /home/pi/CONTROL2

CELL_COUNTER=100
#EVROUTER_COUNTER=100
WVDIAL_COUNTER=100
DRIVER_COUNTER=100
#LEAK_COUNTER=0

#(

#for model 16 - redo progress bar
URT=`kdialog --progressbar "Screen Setup" 4`
sleep 1
#for model 17 - use conventional style power management
#for model 22 - do not mess with power management for now
#sudo sh -c "echo 'conservative' >> /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor"
#for x86 pc stick
#sudo sh -c "echo 'powersave' >> /sys/devices/system/cpu/cpufreq/policy0/scaling_governor"
#sudo sh -c "echo 'powersave' >> /sys/devices/system/cpu/cpufreq/policy1/scaling_governor"
#sudo sh -c "echo 'powersave' >> /sys/devices/system/cpu/cpufreq/policy2/scaling_governor"
#sudo sh -c "echo 'powersave' >> /sys/devices/system/cpu/cpufreq/policy3/scaling_governor"
#sudo cpupower frequency-set --governor powersave
#echo "10"
#echo "# Thermal and Energy Management Setup"
#set cpu to max speed when load reaches 95%
#works combined with arm_freq_min=500 in config.txt
#sudo sh -c "echo '95' >> /sys/devices/system/cpu/cpufreq/ondemand/up_threshold"
#for odroid c2
#sudo sh -c "echo 'ondemand' >> /sys/devices/system/cpu/cpufreq/policy0/scaling_governor"
#disable ethernet - saves 50ma
#/home/pi/hub-ctrl.c/hub-ctrl -h 0 -P 1 -p 0

#echo "20"
#echo "# Touchscreen Setup"
#this also sets up hold to right click like on windows
#xinput set-prop 'ADS7846 Touchscreen' 'Evdev Third Button Emulation Button' 3
#xinput set-prop 'ADS7846 Touchscreen' 'Evdev Third Button Emulation Timeout' 750
#xinput set-prop 'ADS7846 Touchscreen' 'Evdev Third Button Emulation' 1
#xinput set-prop 'ADS7846 Touchscreen' 'Evdev Third Button Emulation Threshold' 100
#for model 11
#xinput set-prop 'WaveShare WS170120' 'Evdev Third Button Emulation Button' 3
#xinput set-prop 'WaveShare WS170120' 'Evdev Third Button Emulation Timeout' 750
#xinput set-prop 'WaveShare WS170120' 'Evdev Third Button Emulation' 1
#xinput set-prop 'WaveShare WS170120' 'Evdev Third Button Emulation Threshold' 100
#xinput set-prop 'ADS7846 Touchscreen' 'Evdev Axis Inversion' 0 1
#xinput set-prop 'ADS7846 Touchscreen' 'Evdev Axes Swap' 1
#for model 15 with waveshare 5" capacitive touchscreen
#no calibration needed and old calibration should not interfere
#third button emulation - hold to right click - does not work
#xinput set-prop 'waveshare multi-point Touchscreen' 'Evdev Axis Inversion' 0 1
#xinput set-prop 'waveshare multi-point Touchscreen' 'Evdev Axes Swap' 1
#for model 16 - apparently x86 does not use evdev by default
#~/TOUCH
#for x86 pc stick
#ORIENTATION_STATUS=$( awk '{ print }' /home/pi/ORIENTATION_MODE )
#if [ "$ORIENTATION_STATUS" -eq "0" ]
#then
#~/PORTRAIT_MODE
#fi
#if [ "$ORIENTATION_STATUS" -eq "1" ]
#then
#~/LANDSCAPE_MODE
#fi
xset -dpms
#change below for gtk - and kde now too
#start easystroke for DE independent gesture recognition
easystroke&
#start bluetooth input daemon
#for odroid c2 - no room for bluetooth electrically and physically
#/home/pi/BLUETOOTH_DAEMON&
qdbus $URT Set "" value 1

qdbus $URT setLabelText "Audio Setup"
sleep 1
#echo "30"
#echo "# Audio Setup"
#for odroid c0
#amixer -c 0 sset PCM playback 100%
#amixer -c 1 sset Mic capture 100%
#account for devices sometimes being mixed up
#amixer -c 1 sset toot playback 100%
#amixer -c 2 sset toot playback 100%
amixer -c 1 sset Mic capture 100%
amixer -c 2 sset Mic capture 100%
qdbus $URT Set "" value 2

#everything is started automatically now
#qdbus $URT setLabelText "Modem Manager Setup"
#echo "40"
#echo "# Network Setup"
#prestart modem manager
#all these iterations did not work
#MODEM_OUTPUT=$(sudo ModemManager&)
#sudo ModemManager > /run/shm/MODEM&
#sudo ModemManager 2>&1 /run/shm/MODEM&
#sudo ModemManager 2>&1 | cat > /run/shm/MODEM&
#wait for modem manager to create the virtual modem within dbus
#TIMEOUT_COUNTER=0
#MODEM_STATUS=0
#cancel modemmanager if a more modern device used
#ADAPTER_CHECK_5=$(sudo lsusb -v | grep iInterface | grep 'CDC Ethernet' | wc -l)
#if [ $ADAPTER_CHECK_5 -gt 0 ]
#then
#MODEM_STATUS=1
#fi
#while [  "$MODEM_STATUS" -lt "1" ]
#do
#MODEM_STATUS=$(cat /run/shm/MODEM | grep success | wc -l)
#if [ "$MODEM_STATUS" -eq "1" ]
#then
#enable the modem
#for model 16 - make sure the modem enables
#ENABLE_STATUS=0
#while [  "$ENABLE_STATUS" -lt "1" ]
#do
#sleep 1
#OLD_MODEM_NUMBER=$(mmcli -L | cut -c39)
#ENABLE_STATUS=$(sudo mmcli -m $OLD_MODEM_NUMBER -e | grep success | wc -l)
#done
#fi
#for model 16 - fix things up instead of rebooting
#if [ "$TIMEOUT_COUNTER" -gt "60" ]
#if [ "$TIMEOUT_COUNTER" -gt "30" ]
#then
#kdialog --passivepopup "ModemManager failed - repairing UDEV" 1
#sudo udevadm control --reload
#sudo udevadm trigger
#sleep 5
#~/TOUCH
#for x86 pc stick
#ORIENTATION_STATUS=$( awk '{ print }' /home/pi/ORIENTATION_MODE )
#if [ "$ORIENTATION_STATUS" -eq "0" ]
#then
#~/PORTRAIT_MODE
#fi
#if [ "$ORIENTATION_STATUS" -eq "1" ]
#then
#~/LANDSCAPE_MODE
#fi
#sleep 1
#sudo reboot
#fi
#TIMEOUT_COUNTER=$(($TIMEOUT_COUNTER+1))
#sleep 1
#done
#qdbus $URT Set "" value 3

qdbus $URT setLabelText "Network Dial In"
#initial startup to avoid faulty so and so died messages
#decide what device is being used and set the dialup strategy
ADAPTER_CHECK_1=$(sudo lsusb -v | grep Product | grep 340 | wc -l)
#this is not working anymore
#if [ $ADAPTER_CHECK_1 -gt 0 ]
#then
#sudo mbim-network /dev/cdc-wdm0 start
#sleep 2
#sudo dhclient wwan0
#fi
#for model 17 - previous was more specific and less privileged
#for older kernels
#ADAPTER_CHECK_2=$(lsusb -v | grep Product | grep E398 | wc -l)
#for newer kernels - for model 16
ADAPTER_CHECK_2=$(sudo lsusb -v | grep Product | grep 'HUAWEI Mobile' | wc -l)
if [ $ADAPTER_CHECK_2 -gt 0 ]
then
sudo wvdial&
fi
ADAPTER_CHECK_3=$(sudo lsusb -v | grep Product | grep 313 | wc -l)
ADAPTER_CHECK_4=$(sudo lsusb -v | grep Product | grep 308 | wc -l)
ADAPTER_CHECK_5=$(sudo lsusb -v | grep iInterface | grep 'CDC Ethernet' | wc -l)
#this is an or statement
if [ $ADAPTER_CHECK_1 -gt 0 ] || [ $ADAPTER_CHECK_3 -gt 0 ] || [ $ADAPTER_CHECK_4 -gt 0 ]
then
#these next two devices are transitional between dialup and mbim
#this usually needs special initialization with minicom or other
#also minicom can be used to switch auto connect to primary apn
#this is why some devices seem to connect to data automatically
#so we'll let modemmanager take care of it
#we could echo directly to the device instead of modemmanager
#this also means it needs no initial setup
#data connection dies after a while if idle - seems to be feature
#to reconnect after idling disable/reeneable/connect
PROVIDER=$( awk '{ print }' /home/pi/PROVIDER )
if [ "$PROVIDER" = "ATT" ]
then
sudo mmcli -m 0 --simple-connect="apn=phone"&
fi
if [ "$PROVIDER" = "ATT_PREPAID" ]
then
sudo mmcli -m 0 --simple-connect="apn=broadband"&
fi
if [ "$PROVIDER" = "TMOBILE" ]
then
sudo mmcli -m 0 --simple-connect="apn=fast.t-mobile.com"&
fi
sleep 10
sudo timeout 10s dhclient wwan0
fi
#these are adapter 5 class devices
#let us talk for a moment about them
#these do not work like traditional modems
#they use no legacy protocols like mbim or AT
#they simply present a usb networking device
#this device can receive dhcp communiques
#presumably from router device at usb endpoint
#this means there is no modemmanager
#no outgoing texts so data card preferred
#incoming texts/signal/settings at gateway
#signal could be scraped from gateway html
#check has to go above to cancel modemmanager
#if [ $ADAPTER_CHECK_5 -gt 0 ]
#then
#sudo timeout 10s dhclient usb0
#fi

#reset the signal indicator
echo 0 > /home/pi/SIGNAL_READOUT
#start up the signal indicator helper
python /home/pi/SIGNAL_ICON.py&
#start up the notification indicator helper
python /home/pi/NOTIFICATION_ICON.py&
#for odroid c0
#reset the battery indicator high to prevent shutdown
echo 9 > /home/pi/SIGNAL_READOUT
#start up the battery indicator helper
python /home/pi/BATTERY_ICON.py&
qdbus $URT Set "" value 3

qdbus $URT setLabelText "Application Startup"
sleep 1
#echo "50"
#echo "# Application Startup"
#for model 16 - add deletion to debug menu instead
#prevent modem manager as root from crashing by deleting config
#sudo rm -r /root/.local/share/modem-manager-gui
#rm -r /home/pi/.local/share/modem-manager-gui
#for odroid c0 - text workaround does not work with kdesudo
if [ $ADAPTER_CHECK_5 -lt 1 ]
then
sudo -E modem-manager-gui&
fi
#kdesudo modem-manager-gui&
#kopete&
#pidgin&
linphone&
claws-mail&
qdbus $URT Set "" value 4
#kdialog --passivepopup "Enable cellular device in Modem Manager to finish boot" 1

#echo "60"
#echo "# Miscellaneous Tasks"
#remove to prevent disk space buildup - needed for gtk
#sudo rm /home/pi/.xsession-errors

#echo "100"
#echo "# Startup Complete"
#auto close progress dialog
#weird behavior here with kdialog and killall
#killall kdialog
killall kdialog_progres
#wait for a few seconds so modem manager can get started
sleep 10
#minimize open applications
wmctrl -k on

#)| zenity --progress --pulsate --no-cancel --auto-close --title="TEST1" --text="TEST2" --percentage=0

while true
do

#for vim3 - detect wake from true sleep aka suspend and do something
if [ "$DRIVER_COUNTER" -gt 30 ]
then
DRIVER_COUNTER=0
#get the timestamp for the latest wakeup event
CURRENT_WAKEUP_TIMESTAMP_PRE=$(sudo dmesg | grep cectx | grep wakeup | cut -d "[" -f2 | cut -d "]" -f1 | tail -n1)
#convert to integer
CURRENT_WAKEUP_TIMESTAMP=$(echo $CURRENT_WAKEUP_TIMESTAMP_PRE/1 | bc)
#echo $CURRENT_WAKEUP_TIMESTAMP
if [ "$CURRENT_WAKEUP_TIMESTAMP" -gt "$STORED_WAKEUP_TIMESTAMP" ]
then
STORED_WAKEUP_TIMESTAMP=$CURRENT_WAKEUP_TIMESTAMP
#echo "wakie wakie"
#echo $STORED_WAKEUP_TIMESTAMP
#bugged - set to heartbeat before setting to none
kdialog --passivepopup "Wakeup - please allow time for cellular device to recover" 1
sudo sh -c "echo 'heartbeat' >> /sys/class/leds/sys_led/trigger"
sudo sh -c "echo 'none' >> /sys/class/leds/sys_led/trigger"
sudo sh -c "echo 'heartbeat' >> /sys/class/leds/red_led/trigger"
fi
fi

#for model 16 - sleep mode
#previously the power switch existed only to reset screen
#this turns what was an awkward hardware workaround into a sleep function
#when switch is off the device will now go to sleep
#this has the side effect of disabling audio notifications while asleep
#an led notification light or a built in light may be able to be used instead
#disabled for x86 pc stick because there is no switch
#if [ "$DRIVER_COUNTER" -gt 5 ]
#then
#DRIVER_COUNTER=0
#SCREEN_CHECK=$(lsusb | grep D-WAV | wc -l)
#SLEEP_STATUS=$(cat /home/pi/SLEEP_STATUS)
#if [ $SLEEP_STATUS -eq "1" ]
#then
#if [ $SCREEN_CHECK -gt 0 ]
#then
#kdialog --passivepopup "Wakeup" 1
#echo 0 > /home/pi/SLEEP_STATUS
#~/TOUCH
#sudo cpupower frequency-set --governor performance
#fi
#fi
#if [ $SLEEP_STATUS -eq "0" ]
#then
#if [ $SCREEN_CHECK -lt 1 ]
#then
#kdialog --passivepopup "Zzzzzzz" 1
#echo 1 > /home/pi/SLEEP_STATUS
#sudo cpupower frequency-set --governor powersave
#fi
#fi
#fi

#for model 16 - disabled to save battery life
#keeps the touchscreen driver running well no matter what
#this fixes touchscreen input failure after sleeping
#disabling irq #505/irq 505 nobody cared
#if [ "$DRIVER_COUNTER" -gt 60 ]
#then
#DRIVER_COUNTER=0
#DRIVER_CHECK=$(dmesg | grep irq | grep nobody | wc -l)
#if [ "$DRIVER_CHECK" -gt "1" ]
#then
#kdialog --passivepopup "Touchscreen driver died - taking no action" 1
#zenity --notification --window-icon="info" --text "Touchscreen driver died - taking no action"&
#kdialog --passivepopup "Touchscreen driver died - restarting" 1
#sudo modprobe -r ads7846
#sleep 1
#sudo modprobe ads7846
#sleep 1
#sudo killall evrouter
#sleep 5
#dmesg > /home/pi/DMESG_BACKUP
#sudo dmesg -c
#fi
#fi

#starts wvdial/kopete/linphone/icedove
#keeps it running no matter what
if [ "$WVDIAL_COUNTER" -gt 30 ]
then
WVDIAL_COUNTER=0
#adapter 5 does not use modemmanager
if [ $ADAPTER_CHECK_5 -lt 1 ]
then
#check if modemmanager has found a modem at all
MODEM_EXISTENCE_CHECK=$(mmcli -L | grep org | wc -l)
if [ "$MODEM_EXISTENCE_CHECK" -lt "1" ]
then
#tell modemmanager to stop being lazy
kdialog --passivepopup "Rescanning for modems - standby" 1
mmcli -S
fi
#check for new modem enumeration and reenable
#there is a different position for modem index number now
#MODEM_NUMBER=$(mmcli -L | cut -c39)
#check that we have a number and update if so
#MODEM_NUMBER_PRE=$(mmcli -L | cut -c42-43)
MODEM_NUMBER_PRE=$(mmcli -L | cut -d "/" -f6 | cut -d " " -f1)
if [ "$MODEM_NUMBER_PRE" -eq "$MODEM_NUMBER_PRE" ] 2>/dev/null
then
MODEM_NUMBER=$MODEM_NUMBER_PRE
fi
if [ "$MODEM_NUMBER" -gt "$OLD_MODEM_NUMBER" ]
then
#for model 16 - make sure the modem enables
ENABLE_STATUS=0
OLD_MODEM_NUMBER=$MODEM_NUMBER
while [  "$ENABLE_STATUS" -lt "1" ]
do
kdialog --passivepopup "Reenabling modem manager after new modem enumeration" 1
sleep 3
#there is a different position for modem index number now
#OLD_MODEM_NUMBER=$(mmcli -L | cut -c39)
#OLD_MODEM_NUMBER=$(mmcli -L | cut -c42-43)
OLD_MODEM_NUMBER=$(mmcli -L | cut -d "/" -f6 | cut -d " " -f1)
ENABLE_STATUS=$(sudo mmcli -m $OLD_MODEM_NUMBER -e | grep success | wc -l)
#better reset touchscreen calibration here too
xinput set-prop 'waveshare multi-point Touchscreen' 'Coordinate Transformation Matrix' 0 1 0 -1 0 1 0 0 1
done
fi
fi
#BURT=$(ps aux | grep wvdial | wc -l)
#if [ "$BURT" -lt 2 ]
#mystery restart fix here and lines below
#PERSISTENT_ADAPTER_CHECK_1=$(lsusb -v | grep Product | grep 340 | wc -l)
#PERSISTENT_ADAPTER_CHECK_2=$(lsusb -v | grep Product | grep E398 | wc -l)
#PERSISTENT_ADAPTER_CHECK_3=$(lsusb -v | grep Product | grep 313 | wc -l)
#PERSISTENT_ADAPTER_CHECK_4=$(lsusb -v | grep Product | grep 308 | wc -l)
#maintain 340 connection
#this is not working anymore
#if [ $ADAPTER_CHECK_1 -gt 0 ]
#then
#check for lack of ip address
#CONNECTION_CHECK=$(sudo ifconfig -a | grep -w inet | wc -l)
#if [ $CONNECTION_CHECK -lt 2 ]
#then
#kdialog --passivepopup "Restarting MBIM-based connection / Reason: Lack of IP" 1
#echo 0 > /home/pi/SIGNAL_READOUT
#zenity --notification --window-icon="info" --text "MBIM died - restarting"&
#sudo mbim-network /dev/cdc-wdm0 start
#sudo killall dhclient
#sudo dhclient wwan0
#fi
#check for general loss of connection
#when the route command hangs we are not connected
#timeout can be tuned here
#GATEWAY_CHECK=$(sudo timeout 7 route | grep default | wc -l)
#if [ $GATEWAY_CHECK -lt 1 ]
#then
#kdialog --passivepopup "Restarting MBIM-based connection / Reason: Lack of Gateway" 1
#echo 0 > /home/pi/SIGNAL_READOUT
#sudo mbim-network /dev/cdc-wdm0 start
#sudo killall dhclient
#sudo dhclient wwan0
#fi
#fi
#maintain 303 connection
#for model 16 - make model specific again
if [ $ADAPTER_CHECK_2 -gt 0 ]
then
if ! ps -C wvdial
then
kdialog --passivepopup "Restarting wvdial-based connection / Reason: wvdial died" 1
echo 0 > /home/pi/SIGNAL_READOUT
#zenity --notification --window-icon="info" --text "WVdial died - restarting"&
sudo wvdial&
fi
fi
#for model 16
#wvdial appears to work differently now
#it starts the connection and then quits
#this means we can not check that it is running
#suppress 2 warnings
#CARRIER_CHECK=$(cat /sys/class/net/ppp0/carrier 2>/dev/null)
#this checks if the value is actually a number
#if [ "$CARRIER_CHECK" -eq "$CARRIER_CHECK" ] 2>/dev/null
#then
#echo "VALID"
#if [ $CARRIER_CHECK -lt 1 ]
#then
#kdialog --passivepopup "Restarting wvdial-based connection / Reason: No Carrier" 1
#echo 0 > /home/pi/SIGNAL_READOUT
#sudo wvdial&
#fi
#else
#echo "INVALID"
#kdialog --passivepopup "Restarting wvdial-based connection / Reason: No Connection" 1
#echo 0 > /home/pi/SIGNAL_READOUT
#sudo wvdial&
#fi
#fi
#maintain 308 and 313 connection
#this is also for when connection is not ready at bootup
#determine modem number - these devices disconnect/renumber randomly
#there is a different position for modem index number now
#MODEM_NUMBER=$(mmcli -L | cut -c39)
#this is redundant
#MODEM_NUMBER=$(mmcli -L | cut -c42)
#determine cellular provider
PROVIDER=$( awk '{ print }' /home/pi/PROVIDER )
#this is an or statement
if [ $ADAPTER_CHECK_1 -gt 0 ] || [ $ADAPTER_CHECK_3 -gt 0 ] || [ $ADAPTER_CHECK_4 -gt 0 ]
then
#check for lack of ip address
IP_CHECK_ACTION=0
CONNECTION_CHECK=$(sudo ifconfig -a | grep -w inet | wc -l)
if [ $CONNECTION_CHECK -lt 2 ]
#if [ $CONNECTION_CHECK -lt 3 ]
then
IP_CHECK_ACTION=1
kdialog --passivepopup "Restarting modemmanager-based connection / Reason: Lack of IP" 1
echo 0 > /home/pi/SIGNAL_READOUT
#connection routine for modemmanager-based devices
if [ "$PROVIDER" = "ATT" ]
then
sudo mmcli -m $MODEM_NUMBER --simple-connect="apn=phone"&
fi
if [ "$PROVIDER" = "ATT_PREPAID" ]
then
sudo mmcli -m $MODEM_NUMBER --simple-connect="apn=broadband"&
fi
if [ "$PROVIDER" = "TMOBILE" ]
then
sudo mmcli -m $MODEM_NUMBER --simple-connect="apn=fast.t-mobile.com"&
fi
sudo killall dhclient
sudo timeout 20s dhclient wwan0
fi #connection check
#this is the newest method but not working
#CARRIER_CHECK=$(cat /sys/class/net/wwan0/carrier)
#ip link show is probably using data from carrier
#/sys/class/wwan0/operstate is probably similar to carrier
#the RUNNING state in ifconfig is probably taken from carrier
#the good old route check should still work and is probably best
#this timeout needs to be much more generous
#CARRIER_CHECK=$(sudo timeout 7 route | grep default | wc -l)
CARRIER_CHECK=$(sudo timeout 30 route | grep default | wc -l)
#vim3 has virtual ethernet device with ip so increase check by 1
#this keeps both reconnection routines from interfering
if [ "$IP_CHECK_ACTION" -lt 1 ]
then
if [ $CARRIER_CHECK -lt 1 ]
#if [ $CARRIER_CHECK -lt 2 ]
then
echo 0 > /home/pi/SIGNAL_READOUT
#this and the loop that reenables may not be necessary
#testing shows only the reconnect routine/dhclient needs to run
#seems to break enumeration as well - shutdown for testing
#because it does not check if modem number is > old modem number
#when the modem is resetting it puts garbage into the variables
#because mmcli gets nothing when modem is in reset state
#the greater than check keeps insane things from happening
#sudo mmcli -m $MODEM_NUMBER -d
#for model 16 - make sure the modem enables
#ENABLE_STATUS=0
#while [  "$ENABLE_STATUS" -lt "1" ]
#do
kdialog --passivepopup "Restarting modemmanager-based connection / Reason: Lack of Carrier" 1
#connection routine for modemmanager-based devices
if [ "$PROVIDER" = "ATT" ]
then
sudo mmcli -m $MODEM_NUMBER --simple-connect="apn=phone"&
fi
if [ "$PROVIDER" = "ATT_PREPAID" ]
then
sudo mmcli -m $MODEM_NUMBER --simple-connect="apn=broadband"&
fi
if [ "$PROVIDER" = "TMOBILE" ]
then
sudo mmcli -m $MODEM_NUMBER --simple-connect="apn=fast.t-mobile.com"&
fi
sudo killall dhclient
sudo timeout 20s dhclient wwan0
fi #carrier check
fi #ip check action
#this way does not work
#because we can get into a state where he have valid ip and route
#however the cellular device is disconnected
#check for general loss of connection
#when the route command hangs we are not connected
#timeout can be tuned here
#GATEWAY_CHECK=$(sudo timeout 7 route | grep default | wc -l)
#if [ $GATEWAY_CHECK -lt 1 ]
#then
#kdialog --passivepopup "Restarting modemmanager-based connection / Reason: Lack of Gateway" 1
#echo 0 > /home/pi/SIGNAL_READOUT
#sudo mmcli -m $MODEM_NUMBER -d
#sudo mmcli -m $MODEM_NUMBER -e
#connection routine for modemmanager-based devices
#if [ "$PROVIDER" = "ATT" ]
#then
#sudo mmcli -m $MODEM_NUMBER --simple-connect="apn=phone"&
#fi
#if [ "$PROVIDER" = "ATT_PREPAID" ]
#then
#sudo mmcli -m $MODEM_NUMBER --simple-connect="apn=broadband"&
#fi
#if [ "$PROVIDER" = "TMOBILE" ]
#then
#sudo mmcli -m $MODEM_NUMBER --simple-connect="apn=fast.t-mobile.com"&
#fi
#sudo killall dhclient
#sudo dhclient wwan0
#fi
#check for sierra_net driver signaling an unwanted idle
#only a problem with devices that do not auto connect to apn
#this way seems bugged - sierra_idle may be a red herring
#NEW_IDLE_COUNT=$(dmesg | grep sierra | grep idle | wc -l)
#if [ $NEW_IDLE_COUNT -gt $OLD_IDLE_COUNT ]
#then
#kdialog --passivepopup "Recovering from idle condition - please wait 30 seconds" 1
#echo 0 > /home/pi/SIGNAL_READOUT
#sleep 25
#sudo mmcli -m 0 -d
#sudo mmcli -m 0 -e
#PROVIDER=$( awk '{ print }' /home/pi/PROVIDER )
#if [ "$PROVIDER" = "ATT" ]
#then
#sudo mmcli -m 0 --simple-connect="apn=phone"&
#fi
#if [ "$PROVIDER" = "ATT_PREPAID" ]
#then
#sudo mmcli -m 0 --simple-connect="apn=broadband"&
#fi
#if [ "$PROVIDER" = "TMOBILE" ]
#then
#sudo mmcli -m 0 --simple-connect="apn=fast.t-mobile.com"&
#fi
#fi
#OLD_IDLE_COUNT=$NEW_IDLE_COUNT
fi #adapter check
if [ $ADAPTER_CHECK_5 -gt 0 ]
then
CONNECTION_CHECK=$(sudo ifconfig -a | grep -w inet | wc -l)
if [ $CONNECTION_CHECK -lt 2 ]
#if [ $CONNECTION_CHECK -lt 3 ]
then
kdialog --passivepopup "Restarting CDC Ethernet-based connection / Reason: Lack of IP" 1
sudo killall dhclient
sudo timeout 25s dhclient usb0
fi
CARRIER_CHECK=$(sudo timeout 7 route | grep default | wc -l)
if [ $CARRIER_CHECK -lt 1 ]
#if [ $CARRIER_CHECK -lt 2 ]
then
kdialog --passivepopup "Restarting CDC Ethernet-based connection / Reason: Lack of Carrier" 1
sudo killall dhclient
sudo timeout 25s dhclient usb0
fi
fi

#KOPETE_CHECK=$(ps aux | grep kopete | wc -l)
#if [ "$KOPETE_CHECK" -lt 2 ]
#change below for gtk
#if ! ps -C kopete
#if ! ps -C pidgin
#then
#kdialog --passivepopup "Messaging died - restarting" 1
#zenity --notification --window-icon="info" --text "Messaging died - restarting"&
#change below for gtk
#kopete&
#pidgin&
#fi
#LINPHONE_CHECK=$(ps aux | grep linphone | wc -l)
#if [ "$LINPHONE_CHECK" -lt 2 ]
if ! ps -C linphone
then
kdialog --passivepopup "Phone died - restarting" 1
#zenity --notification --window-icon="info" --text "Phone died - restarting"&
linphone&
fi
#ICEDOVE_CHECK=$(ps aux | grep icedove | wc -l)
#if [ "$ICEDOVE_CHECK" -lt 2 ]
if ! ps -C claws-mail
then
kdialog --passivepopup "Email died - restarting" 1
#zenity --notification --window-icon="info" --text "Email died - restarting"&
claws-mail&
fi
if [ $ADAPTER_CHECK_5 -lt 1 ]
then
#bugged on vim3
#if ! ps -C modem-manager-gui
if ! ps -C modem-manager-g
then
kdialog --passivepopup "SMS died - restarting" 1
#for model 16 - add deletion to debug menu instead
#prevent modem manager as root from crashing by deleting config
#sudo rm -r /root/.local/share/modem-manager-gui
#rm -r /home/pi/.local/share/modem-manager-gui
#for odroid c0 - text workaround does not work with kdesudo
sudo -E modem-manager-gui&
#kdesudo modem-manager-gui&
fi
fi
#for odroid c0
if ! ps -C easystroke
then
#don't want or here because it would fire when one is running
#because the other game is not running it would restart gestures
#if [ ! ps -C NUMPTYPHYSICS ] && [ ! ps -C PINBALL ]
#if ! ps -C NUMPTYPHYSICS && ! ps -C PINBALL
if ! ps -C NUMPTYPHYSICS && ! ps -C PINBALL && ! ps -C chromium && ! ps -C retroarch
then
kdialog --passivepopup "Gestures died - restarting" 1
easystroke&
fi
fi
fi

#change below for gtk
#starts evrouter and keeps it running no matter what
#if [ "$EVROUTER_COUNTER" -gt 3 ]
#then
#EVROUTER_COUNTER=0
#URT=$(ps aux | grep evrouter | wc -l)
##if [ "$URT" -lt 2 ]
#if ! ps -C evrouter
#then
#kdialog --passivepopup "Evrouter died - Restarting" 1
#sudo rm /tmp/.evrouter\:0
#kdesudo evrouter /dev/input/event*
#fi
#fi

#sends an AT query to the cellular device for signal
#a delay here causes the secondary not to catch the signal
#if [ "$CELL_COUNTER" -gt 15 ]
#then
#CELL_COUNTER=0
#disabled for new signal strength routine
#sudo echo -e -n 'AT+CSQ\r' > /dev/ttyUSB2
#fi

if [ "$CELL_COUNTER" -gt 30 ]
then
CELL_COUNTER=0
#build convenience popup data
#xfce notification timeout should be around ??? seconds now???
#setup gammu
#truncate -s 0 /run/user/HOOT
#timeout 10s gammu monitor > /run/user/HOOT
#query for signal - gammu
#RESULTANT_1=`cat /run/user/HOOT | grep -m 1 signal`
#determine modem number - for devices that disconnect/renumber randomly
#there is a different position for modem index number now
#MODEM_NUMBER=$(mmcli -L | cut -c39);
#this is redundant
#MODEM_NUMBER=$(mmcli -L | cut -c42);
#query for signal - modemmanager
#complete rewrite here
#RESULTANT_1=`mmcli -m $MODEM_NUMBER --simple-status | grep signal | cut -c29-30 | tr '\'\' ' '`
RESULTANT_1=`mmcli -m $MODEM_NUMBER | grep signal | cut -d"%" -f1 | cut -d":" -f2 | cut -d" " -f2`
#decide how many signal bars to signal for - icon 1
if [ "$RESULTANT_1" -gt 40 ]
then
echo 5 > /home/pi/SIGNAL_READOUT
fi
if [ "$RESULTANT_1" -le 40 ]
then
echo 4 > /home/pi/SIGNAL_READOUT
fi
if [ "$RESULTANT_1" -le 30 ]
then
echo 3 > /home/pi/SIGNAL_READOUT
fi
if [ "$RESULTANT_1" -le 20 ]
then
echo 2 > /home/pi/SIGNAL_READOUT
fi
if [ "$RESULTANT_1" -le 10 ]
then
echo 1 > /home/pi/SIGNAL_READOUT
fi
#decide what to do with user notification -  icon 2
#check number of unread messages - gammu
#RESULTANT_2=`cat /run/user/HOOT | grep -m 1 Phone | cut -c31-39`
#check number of unread messages - modemmanager
#make root sms database world readable so cat can read it
sudo chmod -R 777 /root/.local/share/
#also make local database world readable for alternate case
sudo chmod -R 777 /home/pi/.local/share/
#check root sms but if kdesudo not running check user sms
RESULTANT_2=`cat /root/.local/share/modem-manager-gui/devices/*/sms.gdbm | grep -a '<read>0' | wc -l`
#for odroid c0 - disabled because kdesudo not used
#fix sms notifications again - this never should have been commented out
if ! ps -C kdesudo
then
RESULTANT_2=`cat /home/pi/.local/share/modem-manager-gui/devices/*/sms.gdbm | grep -a '<read>0' | wc -l`
fi
if [ "$RESULTANT_2" -gt 0 ]
then
echo "Unread SMS"
#play a fairly unobtrusive sound
#run in background to stop hangups when there are problems with sound
#for model 16 - stock sounds have changed
#aplay /usr/share/sounds/pop.wav&
aplay /usr/share/games/pinball/tux/up.wav&
#signal for indicator
echo 1 > /home/pi/NOTIFICATION_READOUT
fi
#read linphone history for missed calls
#alternate - show more call detail but less number of calls
#RESULTANT_3=`cat /home/pi/.linphonerc | grep -A1 status=2 | grep from`
#RESULTANT_3=`cat /home/pi/.linphonerc | grep -A1 status=2 | grep from | cut -d ":" -f2 | cut -c1-10`
RESULTANT_3=`cat /home/pi/.linphonerc | grep -A1 status=2 | grep from | cut -d ":" -f2 | cut -c1-10 | wc -l`
if [ "$RESULTANT_3" -gt 0 ]
then
echo "Missed Call"
#play a fairly unobtrusive sound
#run in background to stop hangups when there are problems with sound
#for model 16 - stock sounds have changed
#aplay /usr/share/sounds/pop.wav&
aplay /usr/share/games/pinball/tux/up.wav&
#signal for indicator
echo 2 > /home/pi/NOTIFICATION_READOUT
fi
#reset signal for indicator
#this is an and statement
if [ "$RESULTANT_2" -eq 0 ] && [ "$RESULTANT_3" -eq 0 ]
then
echo 0 > /home/pi/NOTIFICATION_READOUT
fi
#manage and display status of battery system - icon 3
#for odroid c0
RAW_VOLTAGE=$(cat /sys/class/saradc/saradc_ch0)
#~3.22v - hopefully enough to avoid built in battery protection shutdown
#for model 16 - suppress some errors
if [ "$RAW_VOLTAGE" -lt 785 ] 2>/dev/null
then
echo 0 > /home/pi/BATTERY_READOUT
#good place for automatic shutdown in case of low battery
#will work well with c0 because it uses nothing when shutdown
kdialog --passivepopup "Battery level critical - shutdown in 30 seconds - save all work!" 1
sleep 30
#for model 22 - just in case
#sudo shutdown -h now
fi
if [ "$RAW_VOLTAGE" -ge 785 ] 2>/dev/null
then
echo 1 > /home/pi/BATTERY_READOUT
fi
if [ "$RAW_VOLTAGE" -gt 825 ] 2>/dev/null
then
echo 2 > /home/pi/BATTERY_READOUT
fi
if [ "$RAW_VOLTAGE" -gt 850 ] 2>/dev/null
then
echo 3 > /home/pi/BATTERY_READOUT
fi
if [ "$RAW_VOLTAGE" -gt 875 ] 2>/dev/null
then
echo 4 > /home/pi/BATTERY_READOUT
fi
if [ "$RAW_VOLTAGE" -gt 900 ] 2>/dev/null
then
echo 5 > /home/pi/BATTERY_READOUT
fi
if [ "$RAW_VOLTAGE" -gt 925 ] 2>/dev/null
then
echo 6 > /home/pi/BATTERY_READOUT
fi
if [ "$RAW_VOLTAGE" -gt 950 ] 2>/dev/null
then
echo 7 > /home/pi/BATTERY_READOUT
fi
if [ "$RAW_VOLTAGE" -gt 975 ] 2>/dev/null
then
echo 8 > /home/pi/BATTERY_READOUT
fi
#~4.106v - happened to loosely correspond - adc is imperfect anyway
if [ "$RAW_VOLTAGE" -gt 1000 ] 2>/dev/null
then
echo 9 > /home/pi/BATTERY_READOUT
fi
#display convenience popup - disabled now
#kdialog --passivepopup "Unread SMS:$RESULTANT_2/Missed Calls:$RESULTANT_3" 1
#LOCK_STATUS=$( awk '{ print }' /home/pi/LOCK_STATUS )
#if [ $LOCK_STATUS -lt 1 ]
#then
#killall zenity
#if zenity --notification --window-icon="question" --text "$RESULTANT_1/Unread SMS:$RESULTANT_2/Missed Calls:$RESULTANT_3"
#then
#echo 1 > /home/pi/MOVE_NOTIFICATION
#fi&
#fi
#MOVE_NOTIFICATION=$( awk '{ print }' /home/pi/MOVE_NOTIFICATION )
#if [ $MOVE_NOTIFICATION -gt 0 ]
#then
#echo 0 > /home/pi/MOVE_NOTIFICATION
#get current notification location
#QUERY=$(xfconf-query --channel xfce4-notifyd --property /notify-location)
#compute new notification location
#QUERY=$(($QUERY+1))
#if [ $QUERY -gt 3 ]
#then
#QUERY=0
#fi
#set new notification location
#xfconf-query --channel xfce4-notifyd --property /notify-location --set $QUERY
#fi
#beginning of sleep routine
#go to sleep after 10 minutes if no keyboard plugged
#no way to detect charger so look for a keyboard instead
#uncomment below to enable automatic sleep
#IDLE_TIME=$(xprintidle)
#if [ "$IDLE_TIME" -gt 600000 ]
#then
#KEYBOARD_CHECK=$(sudo lsusb -v 2>/dev/null | grep Keyboard | wc -l)
#if [ "$KEYBOARD_CHECK" -lt 1 ]
#then
#kdialog --passivepopup "night night" 1
#sudo sh -c "echo 'standby' >> /sys/power/state"
#fi
#fi
#end of sleep routine
fi

#conventional style power management
#run cpu slowly always until high demand applications are running
#for model 22 - do not mess with power management for now
#if [ "$POWER_COUNTER" -gt 30 ]
#then
#POWER_COUNTER=0
#GOVERNOR_TYPE=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor)
#if ! ( ps -C qupzilla || ps -C firefox-esr )
#then
#if [ "$GOVERNOR_TYPE" = "performance" ]
#then
#sudo sh -c "echo 'conservative' >> /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor"
#fi
#else
#if [ "$GOVERNOR_TYPE" = "conservative" ]
#then
#sudo sh -c "echo 'performance' >> /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor"
#fi
#fi
#fi

#deal with memory leaks - every day for the panel
#if [ "$LEAK_COUNTER" -gt 86400 ]
#then
#zenity --notification --window-icon="info" --text "Panel Restart"&
#killall xfce4-panel
#xfce4-panel&
#sleep 1
#xdotool search --name Buddy windowunmap
#LEAK_COUNTER=0
#fi

#try to avoid double clicks with onscreen keyboard
#cannot detect when plasma keyboard is raised
#can detect other regular on screen keyboard types
#instead just use a dedicated (left) mode when inputting text
#xprop | grep TYPE | grep OVERRIDE - was closest
#but this interfered with kde gestures
#xprop -root _NET_ACTIVE_WINDOW - failed
#wmctl -a :ACTIVE: -v - failed
#xdotool getactivewindow getwindowname - failed

CELL_COUNTER=$(($CELL_COUNTER+1))
#EVROUTER_COUNTER=$(($EVROUTER_COUNTER+1))
WVDIAL_COUNTER=$(($WVDIAL_COUNTER+1))
DRIVER_COUNTER=$(($DRIVER_COUNTER+1))
#LEAK_COUNTER=$(($LEAK_COUNTER+1))
#POWER_COUNTER=$(($POWER_COUNTER+1))
sleep 1

done

